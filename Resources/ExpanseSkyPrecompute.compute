#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

// Each #kernel tells which function to compile; you can have many kernels
/* For now, we'll start with one kernel to compute the transmittance
 * tables. */
#pragma kernel COMPUTE_TRANSMITTANCE main=COMPUTE_TRANSMITTANCE
#pragma kernel COMPUTE_SINGLE_SCATTERING main=COMPUTE_SINGLE_SCATTERING

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Assets/CustomSky/ExpanseSky/ExpanseSkyCommon.hlsl"

/* Transmittance table. Leverages spherical symmetry of the atmosphere,
 * parameterized by:
 * h (x dimension): the height of the camera.
 * phi (y dimension): the zenith angle of the viewing direction. */
RW_TEXTURE2D(float3, _TransmittanceTableRW);

/* Single scattering tables. Leverage spherical symmetry of the atmosphere,
 * parameterized by:
 * h (x dimension): the height of the camera.
 * phi (y dimension): the zenith angle of the viewing direction.
 * phi_l (z dimension): the zenith angle of the light source.
 * nu (w dimension): the azimuth angle of the light source. */
RW_TEXTURE3D(float3, _SingleScatteringTableAirRW);
RW_TEXTURE3D(float3, _SingleScatteringTableAerosolRW);

[numthreads(4,4,1)]
void COMPUTE_TRANSMITTANCE (uint3 id : SV_DispatchThreadID)
{
    /* Get the uv for this id and unwrap it to a viewing angle and a
     * height. */
    float u_r = (id.x + 0.5f) / 32.0;
    float u_mu = (id.y) / 128.0;

    float atmosphereRadius = _planetRadius + _atmosphereThickness;

    float2 r_mu = unmapTransmittanceCoordinates(u_r, u_mu, atmosphereRadius,
      _planetRadius);

    float3 O = float3(0, r_mu.x, 0);
    float3 d = float3(sqrt(max(0.0, 1 - r_mu.y * r_mu.y)), r_mu.y, 0);

    /* See if we're looking at the ground or the sky. */
    float3 t_ground = intersectSphere(O, d, _planetRadius);
    float3 t_atmo = intersectSphere(O, d, atmosphereRadius);
    bool groundHit = floatGT(t_ground.z, 0.0) && (floatGT(t_ground.x, 0.0) || floatGT(t_ground.y, 0.0));
    bool atmoHit = floatGT(t_atmo.z, 0.0) && (floatGT(t_atmo.x, 0.0) || floatGT(t_atmo.y, 0.0));

    /* This is not an aerial view LUT, so we'll have hit either ground or
     * atmo. If we hit ground, we know it's closer than atmo since we're
     * guaranteed to be inside the atmosphere. */
    float3 t = 0.0;
    if (groundHit) {
      t = (t_ground.x < 0.0) ? t_ground.y :
        ((t_ground.y < 0.0) ? t_ground.x : min(t_ground.x, t_ground.y));
    } else {
      t = (t_atmo.x < 0.0) ? t_atmo.y :
        ((t_atmo.y < 0.0) ? t_atmo.x : min(t_atmo.x, t_atmo.y));
    }

    float3 hitPoint = O + t * d;

    /* Compute optical depth for all 3 atmosphere layers. */
    float opticalDepthAir = computeOpticalDepthExponential(O, hitPoint, _planetRadius,
      _scaleHeightAir, _airDensity);
    float opticalDepthOzone = computeOpticalDepthTent(O, hitPoint, _planetRadius,
      _ozoneHeight, _ozoneThickness, _ozoneDensity);
    float opticalDepthAerosol = computeOpticalDepthExponential(O, hitPoint,
      _planetRadius, _scaleHeightAerosols, _aerosolDensity);

    /* Compute transmittance from optical depth. */
    float3 T = exp(-_airCoefficientsF3 * opticalDepthAir
       - _ozoneCoefficientsF3 * opticalDepthOzone
       - 1.1 * _aerosolCoefficient * opticalDepthAerosol);


    _TransmittanceTableRW[id.xy] = T;


    /* Store optical depth instead of transmittance---more useful. */
    // _TransmittanceTableRW[id.xy] = float3(opticalDepthAir, opticalDepthAerosol,
    //   opticalDepthOzone);
}

[numthreads(4,4,4)]
void COMPUTE_SINGLE_SCATTERING (uint3 id : SV_DispatchThreadID)
{
  /* Get the uv for this id and unwrap it to a viewing angle and a
   * height. */
   float u_r = (id.x + 0.5f) / 32.0;
   float u_mu = (id.y + 0.5f) / 256.0;

   uint zTexSize = 16;
   uint zTexCount = 64;

   uint texId = id.z / zTexSize;
   uint texCoord = id.z & (zTexSize - 1);
   float u_mu_l = saturate(texCoord / (float(zTexSize) - 1.0));
   float u_nu = saturate(texId / (float(zTexCount) - 1.0));
   // float u_mu_l = (id.z / 64) / (16.0-1.0);
   // float u_nu = (id.z % 64) / (64.0-1.0);

   float atmosphereRadius = _planetRadius + _atmosphereThickness;

   float4 ssCoord = unmapSingleScatteringCoordinates(u_r, u_mu, u_mu_l, u_nu,
     atmosphereRadius, _planetRadius);

   float3 O = float3(0, ssCoord.x, 0);
   float3 d = normalize(float3(sqrt(max(0.0, 1 - ssCoord.y * ssCoord.y)), ssCoord.y, 0));
   /* TODO: still wrong? Could be causing the artifacts. */
   float3 L = float3(ssCoord.w*sqrt(1 - ssCoord.z*ssCoord.z), ssCoord.z,
    sqrt(1 - ssCoord.w * ssCoord.w)*sqrt(1 - ssCoord.z*ssCoord.z));

   /* See if we're looking at the ground or the sky. */
   float3 t_ground = intersectSphere(O, d, _planetRadius);
   float3 t_atmo = intersectSphere(O, d, atmosphereRadius);
   bool groundHit = floatGT(t_ground.z, 0.0) && (floatGT(t_ground.x, 0.0) || floatGT(t_ground.y, 0.0));
   bool atmoHit = floatGT(t_atmo.z, 0.0) && (floatGT(t_atmo.x, 0.0) || floatGT(t_atmo.y, 0.0));

   /* This is not an aerial view LUT, so we'll have hit either ground or
    * atmo. If we hit ground, we know it's closer than atmo since we're
    * guaranteed to be inside the atmosphere. */
   float t = 0.0;
   if (groundHit) {
     t = (t_ground.x < 0.0) ? t_ground.y :
       ((t_ground.y < 0.0) ? t_ground.x : min(t_ground.x, t_ground.y));
     // _SingleScatteringTableRW[id] = float3(0.0, 0.0, 1.0);
     // return;
   } else {
     // _SingleScatteringTableRW[id] = float3(1.0, 0.0, 0.0);
     // return;
     t = (t_atmo.x < 0.0) ? t_atmo.y :
       ((t_atmo.y < 0.0) ? t_atmo.x : min(t_atmo.x, t_atmo.y));
   }

   // if (dot(L, d) > 0.9) {
   //   _SingleScatteringTableRW[id] = float3(1.0, 0.0, 0.0);
   //   return;
   // } else {
   //   _SingleScatteringTableRW[id] = float3(0.0, 0.0, 1.0);
   //   return;
   // }

   // _SingleScatteringTableRW[id] = float3(0, (ssCoord.w + 1) / 2.0, 0);
   // return;

   float3 hitPoint = O + t * d;

   /* Now, we perform the actual scattering accumulation. */
   // float3 inScatteringAir = float3(0.0, 0.0, 0.0);
   // float3 inScatteringAerosol = float3(0.0, 0.0, 0.0);
   // for (int i = 0; i < _numberOfSamples; i++) {
   //   /* TODO: make this non-linear. */
   //   float sampleT = (((float) i) + 0.5) / ((float) _numberOfSamples);
   //   float ds = t / (float) (_numberOfSamples);
   //   float3 samplePoint = O + d * sampleT * t;
   //
   //   /* Trace a ray from the sample point to the light to check visibility. */
   //   float3 t_light = intersectSphere(samplePoint, L, atmosphereRadius);
   //   float3 t_light_ground = intersectSphere(samplePoint, L, _planetRadius);
   //   bool lightHit = t_light.z >= 0.0 && (t_light.x >= 0.0 || t_light.y >= 0.0);
   //   bool lightGroundHit = t_light_ground.z >= 0.0
   //    && (t_light_ground.x >= 0.0 || t_light_ground.y >= 0.0);
   //   if (lightHit && !lightGroundHit) {
   //     /* Compute the light hit point. */
   //     float3 lightHitPoint = samplePoint + L * max(t_light.x, t_light.y);
   //
   //     /* Compute the scaled densities of air and aerosol layers at the
   //      * sample point. */
   //     float scaledDensityAir = computeDensityExponential(samplePoint,
   //       _planetRadius, _scaleHeightAir, _airDensity) * ds;
   //     float scaledDensityAerosol = computeDensityExponential(samplePoint,
   //       _planetRadius, _scaleHeightAerosols, _aerosolDensity) * ds;
   //
   //     /* Compute transmittance from O to sample point, and then from sample
   //      * point through to the light hit. */
   //     float2 oToSample = mapTransmittanceCoordinates(length(O),
   //       dot(normalize(O), d), atmosphereRadius, _planetRadius, groundHit);
   //     float2 sampleToL = mapTransmittanceCoordinates(length(samplePoint),
   //      dot(normalize(samplePoint), L), atmosphereRadius, _planetRadius,
   //      false);
   //
   //     float3 T_oToSample = SAMPLE_TEXTURE2D_LOD(_TransmittanceTable,
   //       s_linear_clamp_sampler, oToSample, 0).rgb;
   //     float3 T_sampleToL = SAMPLE_TEXTURE2D_LOD(_TransmittanceTable,
   //       s_linear_clamp_sampler, sampleToL, 0).rgb;
   //
   //     /* If we didn't hit the ground, then our transmittance value for
   //      * O to the sample point is too large---we need to subtract off
   //      * the transmittance from the sample point to the atmosphere. */
   //     if (!groundHit) {
   //       float2 sampleOut = mapTransmittanceCoordinates(length(samplePoint),
   //         dot(normalize(samplePoint), d), atmosphereRadius, _planetRadius,
   //         false);
   //       float3 T_sampleOut = SAMPLE_TEXTURE2D_LOD(_TransmittanceTable,
   //         s_linear_clamp_sampler, sampleOut, 0).rgb;
   //       T_oToSample -= T_sampleOut;
   //     }
   //
   //     float3 T = T_oToSample + T_sampleToL;
   //
   //     inScatteringAir += scaledDensityAir * T;
   //     inScatteringAerosol += scaledDensityAerosol * T;
   //   }
   // }

   float3 inScatteringAir = float3(0.0, 0.0, 0.0);
   float3 inScatteringAerosol = float3(0.0, 0.0, 0.0);
   for (int i = 0; i < _numberOfSamples; i++) {
     /* TODO: make this non-linear. */
     float sampleT = (((float) i) + 0.5) / ((float) _numberOfSamples);
     float ds = t / (float) (_numberOfSamples);
     float3 samplePoint = O + d * sampleT * t;

     /* Trace a ray from the sample point to the light to check visibility. */
     float3 t_light = intersectSphere(samplePoint, L, atmosphereRadius);
     float3 t_light_ground = intersectSphere(samplePoint, L, _planetRadius);
     bool lightHit = floatGT(t_light.z, 0.0)
       && (floatGT(t_light.x, 0.0) || floatGT(t_light.y, 0.0));
     bool lightGroundHit = floatGT(t_light_ground.z, 0.0)
      && (floatGT(t_light_ground.x, 0.0) || floatGT(t_light_ground.y, 0.0));
     if (lightHit && !lightGroundHit) {
       /* Compute the light hit point. */
       float3 lightHitPoint = samplePoint + L * max(t_light.x, t_light.y);

       /* Compute the scaled densities of air and aerosol layers at the
        * sample point. */
       float scaledDensityAir = computeDensityExponential(samplePoint,
         _planetRadius, _scaleHeightAir, _airDensity) * ds;
       float scaledDensityAerosol = computeDensityExponential(samplePoint,
         _planetRadius, _scaleHeightAerosols, _aerosolDensity) * ds;

       /* Compute transmittance from O to sample point, and then from sample
        * point through to the light hit. */
       float2 oToSample = mapTransmittanceCoordinates(length(O),
         ssCoord.y, atmosphereRadius, _planetRadius, groundHit);
       float2 sampleToL = mapTransmittanceCoordinates(length(samplePoint),
        clampCosine(dot(normalize(samplePoint), L)), atmosphereRadius, _planetRadius,
        lightGroundHit);

       float3 T_oToSample = SAMPLE_TEXTURE2D_LOD(_TransmittanceTable,
         s_linear_clamp_sampler, oToSample, 0).rgb;
       float3 T_sampleToL = SAMPLE_TEXTURE2D_LOD(_TransmittanceTable,
         s_linear_clamp_sampler, sampleToL, 0).rgb;

       /* If we didn't hit the ground, then our transmittance value for
        * O to the sample point is too large---we need to divide out
        * the transmittance from the sample point to the atmosphere. */
       if (!groundHit) {
         float2 sampleOut = mapTransmittanceCoordinates(length(samplePoint),
           clampCosine(dot(normalize(samplePoint), d)), atmosphereRadius, _planetRadius,
           false);
         float3 T_sampleOut = SAMPLE_TEXTURE2D_LOD(_TransmittanceTable,
           s_linear_clamp_sampler, sampleOut, 0).rgb;
         /* Clamp sample out for division. */
         T_sampleOut = max(T_sampleOut, FLT_EPSILON);
         T_oToSample /= T_sampleOut;
       }

       float3 T = T_oToSample * T_sampleToL;

       inScatteringAir += scaledDensityAir * T;
       inScatteringAerosol += scaledDensityAerosol * T;
     }
   }

   // float dotLd = dot(L, d);
   // float rayleighPhase = 3.f / (16.f * PI) * (1 + dotLd * dotLd);
   // float miePhase = 3.f / (8.0 * PI) * ((1.f - g * g) * (1.f + dotLd * dotLd))
   //   / ((2.f + g * g) * pow(1.f + g * g - 2.f * g * dotLd, 1.5f));
   //
   // float3 finalSingleScattering = (2.0 * _skyTintF3 * _airCoefficientsF3
   //   * inScatteringAir * rayleighPhase
   //   + _aerosolCoefficient * inScatteringAerosol * miePhase);

  _SingleScatteringTableAirRW[id] = inScatteringAir;
  _SingleScatteringTableAerosolRW[id] = inScatteringAerosol;
}
