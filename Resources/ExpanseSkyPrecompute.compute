#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

// Each #kernel tells which function to compile; you can have many kernels
/* For now, we'll start with one kernel to compute the transmittance
 * tables. */
#pragma kernel COMPUTE_TRANSMITTANCE main=COMPUTE_TRANSMITTANCE
#pragma kernel COMPUTE_SINGLE_SCATTERING main=COMPUTE_SINGLE_SCATTERING
#pragma kernel COMPUTE_GROUND_IRRADIANCE main=COMPUTE_GROUND_IRRADIANCE

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Assets/CustomSky/ExpanseSky/code/ExpanseSkyCommon.hlsl"

/* Transmittance table. Leverages spherical symmetry of the atmosphere,
 * parameterized by:
 * h (x dimension): the height of the camera.
 * phi (y dimension): the zenith angle of the viewing direction. */
RW_TEXTURE2D(float3, _TransmittanceTableRW);

/* Single scattering tables. Leverage spherical symmetry of the atmosphere,
 * parameterized by:
 * h (x dimension): the height of the camera.
 * phi (y dimension): the zenith angle of the viewing direction.
 * phi_l (z dimension): the zenith angle of the light source.
 * nu (w dimension): the azimuth angle of the light source. */
RW_TEXTURE3D(float3, _SingleScatteringTableAirRW);
RW_TEXTURE3D(float3, _SingleScatteringTableAerosolRW);

/* Ground irradiance table. Leverages spherical symmetry of the atmosphere,
 * parameterized by:
 * phi (x dimension): dot product between the surface normal and the
 * light direction. */
RW_TEXTURE2D(float3, _GroundIrradianceTableAirRW);
RW_TEXTURE2D(float3, _GroundIrradianceTableAerosolRW);

[numthreads(4,4,1)]
void COMPUTE_TRANSMITTANCE (uint3 id : SV_DispatchThreadID)
{
    /* Get the uv for this id and unwrap it to a viewing angle and a
     * height. */
    float u_r = (id.x + 0.5f) / float(TRANSMITTANCE_TABLE_SIZE_H);
    float u_mu = (id.y + 0.5f) / float(TRANSMITTANCE_TABLE_SIZE_PHI);

    float2 r_mu = unmapTransmittanceCoordinates(u_r, u_mu, _atmosphereRadius,
      _planetRadius);

    float r = r_mu.x;
    float mu = r_mu.y;

    float3 O = float3(0, r, 0);
    float3 d = float3(sqrt(max(0.0, 1 - mu * mu)), mu, 0);

    /* See if we're looking at the ground or the sky. */
    float3 t_ground = intersectSphere(O, d, _planetRadius);
    float3 t_atmo = intersectSphere(O, d, _atmosphereRadius);
    bool groundHit = floatGT(t_ground.z, 0.0) && (floatGT(t_ground.x, 0.0) || floatGT(t_ground.y, 0.0));
    bool atmoHit = floatGT(t_atmo.z, 0.0) && (floatGT(t_atmo.x, 0.0) || floatGT(t_atmo.y, 0.0));

    /* This is not an aerial view LUT, so we'll have hit either ground or
     * atmo. If we hit ground, we know it's closer than atmo since we're
     * guaranteed to be inside the atmosphere. */
    float3 t = 0.0;
    if (groundHit) {
      t = (t_ground.x < 0.0) ? t_ground.y :
        ((t_ground.y < 0.0) ? t_ground.x : min(t_ground.x, t_ground.y));
    } else {
      t = (t_atmo.x < 0.0) ? t_atmo.y :
        ((t_atmo.y < 0.0) ? t_atmo.x : min(t_atmo.x, t_atmo.y));
    }

    float3 hitPoint = O + t * d;

    /* Compute optical depth for all 3 atmosphere layers. */
    float opticalDepthAir = computeOpticalDepthExponential(O, hitPoint, _planetRadius,
      _scaleHeightAir, _airDensity, _numberOfTransmittanceSamples);
    float opticalDepthOzone = computeOpticalDepthTent(O, hitPoint, _planetRadius,
      _ozoneHeight, _ozoneThickness, _ozoneDensity, _numberOfTransmittanceSamples);
    float opticalDepthAerosol = computeOpticalDepthExponential(O, hitPoint,
      _planetRadius, _scaleHeightAerosols, _aerosolDensity,
      _numberOfTransmittanceSamples);

    /* Compute transmittance from optical depth. */
    float3 T = exp(-_airCoefficientsF3 * opticalDepthAir
       - _ozoneCoefficientsF3 * opticalDepthOzone
       - 1.1 * _aerosolCoefficient * opticalDepthAerosol);

    _TransmittanceTableRW[id.xy] = T;
}

[numthreads(4,4,4)]
void COMPUTE_SINGLE_SCATTERING (uint3 id : SV_DispatchThreadID)
{
  /* Get the uv for this id and unwrap it to a viewing angle, a
   * height, and the sun zenith and azimuth angles. */
  /* Height. */
  float u_r = (id.x + 0.5f) / float(SINGLE_SCATTERING_TABLE_SIZE_H);
  /* Viewing angle. */
  float u_mu = (id.y + 0.5f) / float(SINGLE_SCATTERING_TABLE_SIZE_PHI);

  float2 u_mu_l_u_nu = deepTexIndexToUV(id.z,
    SINGLE_SCATTERING_TABLE_SIZE_PHI_L, SINGLE_SCATTERING_TABLE_SIZE_NU);
  /* Sun zenith angle. */
  float u_mu_l = u_mu_l_u_nu.x;
  /* Sun azimuth angle. */
  float u_nu = u_mu_l_u_nu.y;

  float4 ssCoord = unmapSingleScatteringCoordinates(u_r, u_mu, u_mu_l, u_nu,
    _atmosphereRadius, _planetRadius);

  float r = ssCoord.x;
  float mu = ssCoord.y;
  float mu_l = ssCoord.z;
  float nu = ssCoord.w;

  float3 O = float3(0, r, 0);
  float3 d = normalize(float3(sqrt(max(0.0, 1 - mu * mu)), mu, 0));
  float3 L = float3(nu*sqrt(1 - mu_l*mu_l), mu_l,
    sqrt(1 - nu * nu)*sqrt(1 - mu_l*mu_l));

  /* See if we're looking at the ground or the sky. */
  float3 t_ground = intersectSphere(O, d, _planetRadius);
  float3 t_atmo = intersectSphere(O, d, _atmosphereRadius);
  bool groundHit = floatGT(t_ground.z, 0.0) && (floatGT(t_ground.x, 0.0) || floatGT(t_ground.y, 0.0));
  bool atmoHit = floatGT(t_atmo.z, 0.0) && (floatGT(t_atmo.x, 0.0) || floatGT(t_atmo.y, 0.0));

  /* This is not an aerial view LUT, so we'll have hit either ground or
   * atmo. If we hit ground, we know it's closer than atmo since we're
   * guaranteed to be inside the atmosphere. */
  float t = 0.0;
  if (groundHit) {
    t = (t_ground.x < 0.0) ? t_ground.y :
      ((t_ground.y < 0.0) ? t_ground.x : min(t_ground.x, t_ground.y));
  } else {
    t = (t_atmo.x < 0.0) ? t_atmo.y :
      ((t_atmo.y < 0.0) ? t_atmo.x : min(t_atmo.x, t_atmo.y));
  }

  float3 hitPoint = O + t * d;

  float3 inScatteringAir = float3(0.0, 0.0, 0.0);
  float3 inScatteringAerosol = float3(0.0, 0.0, 0.0);
  for (int i = 0; i < _numberOfScatteringSamples; i++) {
    /* TODO: make this non-linear. */
    float sampleT = 0.0;
    float ds = 0.0;
    if (_useImportanceSampling) {
      /* Distribute samples cubically. This isn't optimal for the ozone
       * layer, which actually samples better using a linear distribution,
       * but around a sample count of 10 is enough to not notice the
       * difference, since we still distribute the ozone samples linearly
       * for the secondary sampling. We could theoretically compute a
       * second sample point here exclusively for the ozone, but that
       * seems inefficient. */
      float2 t_ds = t * generateCubicSampleFromIndex(i, _numberOfScatteringSamples);
      sampleT = t_ds.x;
      ds = t_ds.y;
    } else {
      /* Distribute linearly. */
      float2 t_ds = t * generateLinearSampleFromIndex(i, _numberOfScatteringSamples);
      sampleT = t_ds.x;
      ds = t_ds.y;
    }

    float3 samplePoint = O + d * sampleT;

    /* Trace a ray from the sample point to the light to check visibility. */
    float3 t_light = intersectSphere(samplePoint, L, _atmosphereRadius);
    float3 t_light_ground = intersectSphere(samplePoint, L, _planetRadius);
    bool lightHit = floatGT(t_light.z, 0.0)
      && (floatGT(t_light.x, 0.0) || floatGT(t_light.y, 0.0));
    bool lightGroundHit = floatGT(t_light_ground.z, 0.0)
      && (floatGT(t_light_ground.x, 0.0) || floatGT(t_light_ground.y, 0.0));
    if (lightHit && !lightGroundHit) {
      /* Compute the light hit point. */
      float3 lightHitPoint = samplePoint + L * max(t_light.x, t_light.y);

      /* Compute the scaled densities of air and aerosol layers at the
       * sample point. */
      float scaledDensityAir = computeDensityExponential(samplePoint,
        _planetRadius, _scaleHeightAir, _airDensity) * ds;
      float scaledDensityAerosol = computeDensityExponential(samplePoint,
        _planetRadius, _scaleHeightAerosols, _aerosolDensity) * ds;

      /* Compute transmittance from O to sample point, and then from sample
       * point through to the light hit. */
      float2 oToSample = mapTransmittanceCoordinates(length(O),
        mu, _atmosphereRadius, _planetRadius, t, groundHit);
      float2 sampleToL = mapTransmittanceCoordinates(length(samplePoint),
        clampCosine(dot(normalize(samplePoint), L)), _atmosphereRadius, _planetRadius,
        max(t_light.x, t_light.y), lightGroundHit);

      float3 T_oToSample = SAMPLE_TEXTURE2D_LOD(_TransmittanceTable,
        s_linear_clamp_sampler, oToSample, 0).rgb;
      float3 T_sampleToL = SAMPLE_TEXTURE2D_LOD(_TransmittanceTable,
        s_linear_clamp_sampler, sampleToL, 0).rgb;

      /* If we didn't hit the ground, then our transmittance value for
       * O to the sample point is too large---we need to divide out
       * the transmittance from the sample point to the atmosphere. */
      if (!groundHit) {
        float2 sampleOut = mapTransmittanceCoordinates(length(samplePoint),
          clampCosine(dot(normalize(samplePoint), d)), _atmosphereRadius, _planetRadius,
          length(hitPoint - samplePoint), false);
        float3 T_sampleOut = SAMPLE_TEXTURE2D_LOD(_TransmittanceTable,
          s_linear_clamp_sampler, sampleOut, 0).rgb;
        /* Clamp sample out for division. */
        T_sampleOut = max(T_sampleOut, FLT_EPSILON);
        T_oToSample /= T_sampleOut;
      }

      float3 T = T_oToSample * T_sampleToL;

      inScatteringAir += scaledDensityAir * T;
      inScatteringAerosol += scaledDensityAerosol * T;
    }
  }

  _SingleScatteringTableAirRW[id] = inScatteringAir;
  _SingleScatteringTableAerosolRW[id] = inScatteringAerosol;
}

[numthreads(4,1,1)]
void COMPUTE_GROUND_IRRADIANCE (uint3 id : SV_DispatchThreadID) {
  float u_mu_l = (id.x + 0.5f) / float(GROUND_IRRADIANCE_TABLE_SIZE);
  float u_r = 0.001; /* We are on the ground. */

  /* TODO: create an unmap function for this. */
  float H = sqrt(max(0.0, _atmosphereRadius * _atmosphereRadius - _planetRadius * _planetRadius));
  float rho = u_r * H;
  float r = sqrt(max(0.0, rho * rho + _planetRadius * _planetRadius));
  float mu_l = clampCosine(2.0 * u_mu_l - 1);

  float3 O = float3(0, r, 0);
  float3 L = float3(sqrt(max(0.0, 1 - mu_l * mu_l)), mu_l, 0);

  float3 aerosolContrib = float3(0.0, 0.0, 0.0);
  float3 airContrib = float3(0.0, 0.0, 0.0);
  for (int i = 0; i < _numberOfGroundIrradianceSamples; i++) {
    /* Generate fibonacci hemisphere dir based on i. */
    float3 d = fibonacciHemisphere(i, _numberOfGroundIrradianceSamples);

    float mu = dot(d, normalize(O));

    float3 proj_L = normalize(L - normalize(O) * mu_l);
    float3 proj_d = normalize(d - normalize(O) * dot(normalize(O), d));
    /* Take their dot product to get the cosine of the angle between them. */
    float nu = clampCosine(dot(proj_L, proj_d));

    /* Sample the sky table. */
    float3 t_atmo = intersectSphere(O, d, _atmosphereRadius);
    float t_hit = max(t_atmo.x, t_atmo.y);
    TexCoord5D ssCoord = mapSingleScatteringCoordinates(r, mu, mu_l, nu,
      _atmosphereRadius, _planetRadius, t_hit, false);
    float3 uvw0 = float3(ssCoord.x, ssCoord.y, ssCoord.z);
    float3 uvw1 = float3(ssCoord.x, ssCoord.y, ssCoord.w);

    float3 ssContrib0Air = SAMPLE_TEXTURE3D_LOD(_SingleScatteringTableAir,
      s_trilinear_clamp_sampler, uvw0, 0).rgb;
    float3 ssContrib1Air = SAMPLE_TEXTURE3D_LOD(_SingleScatteringTableAir,
      s_trilinear_clamp_sampler, uvw1, 0).rgb;
    float3 ssContrib0Aerosol = SAMPLE_TEXTURE3D_LOD(_SingleScatteringTableAerosol,
      s_trilinear_clamp_sampler, uvw0, 0).rgb;
    float3 ssContrib1Aerosol = SAMPLE_TEXTURE3D_LOD(_SingleScatteringTableAerosol,
      s_trilinear_clamp_sampler, uvw1, 0).rgb;

    float3 singleScatteringContributionAir = lerp(ssContrib0Air, ssContrib1Air, ssCoord.a);
    float3 singleScatteringContributionAerosol = lerp(ssContrib0Aerosol, ssContrib1Aerosol, ssCoord.a);

    /* Compute single scattering contribution using phase functions. */
    float dot_L_d = dot(L, d);
    float rayleighPhase = computeAirPhase(dot_L_d);
    float miePhase = computeAerosolPhase(dot_L_d, g);

    airContrib += _airCoefficientsF3 * singleScatteringContributionAir
    * rayleighPhase * PI / float(_numberOfGroundIrradianceSamples);
    aerosolContrib += _aerosolCoefficient * singleScatteringContributionAerosol
      * miePhase * PI / float(_numberOfGroundIrradianceSamples);
  }
  _GroundIrradianceTableAirRW[id.xy] = airContrib;
  _GroundIrradianceTableAerosolRW[id.xy] = aerosolContrib;
}
